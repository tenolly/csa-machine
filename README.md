# Лабораторная работа 4
Выполнил: `Пышкин Никита Сергеевич, P3213`<br>
Вариант: `alg | risc | neum | hw | tick | binary | trap | mem | cstr | prob2 | cache`

# Язык программирования
## Описание синтаксиса (Форма Бэкуса-Наура)
```
<программа> ::= <операция> | <операция> <пробельная последовательность> <программа>

<операция> ::= <объявление функции>
    | <вызов функции>
    | <цикл for> 
    | <условный оператор if> 
    | <операция присвоения> 
    | <операция инициализации>

<пробельная последовательность> ::= (<пробел> | <комментарий>) (<пробельная последовательность> | <пусто>)
<комментарий> ::= "#" <последовательность символов> "\n"

<объявление функции> ::= (<тип данных> | "void") <пробельная последовательность> <переменная> "(" (<список аргументов> | <пусто>) ")" "{" 
    (<программа> | <программа> <выход из функции> (<пробельная последовательность> <набор базовых элементов> | <пусто>) ";")
"}"

<список аргументов> ::= <аргумент> | <аргумент> "," <список аргументов>
<аргумент> ::= <переменная> ":" <тип данных>

<вызов функции> ::= <переменная> "(" <набор базовых элементов> ")" ";"
<выход из функции> ::= "return"

<цикл for> ::= "for" "[" 
    (<операция инициализации> | <операция присвоения> | <пусто>) ";" 
    (<булево выражение> | <пусто>) ";"
    (<операция присвоения> | <пусто>) 
"]" "{" <тело цикла> "}"

<тело цикла> ::= <операции в цикле> | <тело цикла> <операции в цикле>
<операции в цикле> ::= <программа> | <манипуляции циклом>
<манипуляции циклом> ::= "break" ";" | "continue" ";"

<условный оператор if> ::= "if" "[" <булево выражение> "]" "{" <программа> "}"

<операция инициализации> ::= <переменная> ":" <тип данных> "=" (<выражение> | <операция ввода>) ";"
<операция присвоения> ::= <переменная> "=" (<выражение> | <операция ввода>) ";"

<операция ввода> ::= "input" "(" (<число> | <пусто>) ")"
<операция вывода> ::= "print" "(" (<набор базовых элементов> | <пусто>) ")"

<тип данных> ::= "int" | "str"

<булево выражение> ::= <булево OR>
<булево OR> ::= <булево AND> | <булево OR> "or" <булево AND>
<булево AND> ::= <булево NOT> | <булево AND> "and" <булево NOT>
<булево NOT> ::= <булева единица> | "not" <булево NOT>
<булева единица> ::= "(" <булево выражение> ")" | <выражение> <операция сравнения> <выражение> 

<выражение> ::= <слагаемое> | <слагаемое> ("+" | "-") <слагаемое> 
<слагаемое> ::= <множитель> | <множитель> ("*" | "/" | "%") <множитель>
<множитель> ::= <базовый элемент> | "(" <выражение> ")"

<операция сравнения> ::= "==" | "<" | "<=" | ">" | ">=" | "!="

<число> ::= <последовательность цифр> 
    | "-" <последовательность цифр>
    | <число> <операция побитового сдвига> <число>

<последовательность цифр> ::= <цифра> | <цифра> <последовательность цифр>

<операция побитового сдвига> ::= "<<" | ">>"

<строка> ::= '"' (<последовательность символов> | <пусто>) '"'
<последовательность символов> ::= <символ> | <символ> <последовательность символов>
<символ> ::= <цифра> | <буква> | <пробел> | "_"

<переменная> ::= (<буква> | "_") | (<буква> | "_") <название переменной>
<название переменной> ::= <символ переменной> | <символ переменной> <название переменной> 
<символ переменной> ::= <цифра> | <буква> | "_"

<набор базовых элементов> ::= <базовый элемент> | <базовый элемент> "," <набор базовых элементов>
<базовый элемент> ::= <переменная> | <число> | <строка> | <вызов функции>

<пусто> ::= ε
<пробел> ::= "\n" | "\t" | " "
<цифра> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<буква> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" 
    | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" 
    | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" 
    | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" 
    | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" 
```
## Описание семантики
### Стратегия вычислений
Аргументы функции вычисляются до вызова функции, слева-направо. Вычисленное значение копируется в новую область памяти, выделенную специально для аргументов функции.
### Область видимости
Область видимости переменных ограничена фигурными скобками, в которых она была объявлена (если переменная объявлена вне скобок, то она находится в глобальной области видимости). За пределами этих фигурных скобок переменная не видна. Переменная может быть успешно изменена в новом уровне вложенности, без создания новой. Переменные с одинаковым именем не могут быть объявлены на одном и том же уровне видимости, но могут быть объявлены на разных (даже если один уровень видимости является вложением для другого).
```
number:int = 3
if [number < 5] {
    number = number + 1;
}
print(number);  # 4
```
```
number:int = 3
if [number < 5] {
    number:int = 4
    number = number + 1;
    print(number);  # 5
}
print(number);  # 3
```
Для функций работают те же правила области видимости, что и для переменных.
```
void do_something() {
    do_print();

    void do_print() {
        print(52);
    }
}

do_something();  # 52
do_print();  # Ошибка
```
### Типизация. Виды литералов
Типизация сильная и строгая. При этом есть следующие типы данных:
 - `str` - строковый тип данных, текст пишется в двойных кавычках.
 - `int` - численный тип данных, используется только для целых чисел.

Булевый тип данных отсутствует, вместо него следует использовать `int`.

# Организация памяти
Будет позже...

# Система команд
Будет позже...

# Транслятор
Будет позже...

# Модель процессора
Будет позже...
