# Лабораторная работа 4
Выполнил: `Пышкин Никита Сергеевич, P3213`<br>
Вариант: `alg | risc | neum | hw | tick | binary | trap | mem | cstr | prob2 | cache`

# Язык программирования
## Описание синтаксиса (Форма Бэкуса-Наура)
```
<программа> ::= <операция> | <операция> <пробельная последовательность> <программа>

<операция> ::= <объявление функции>
    | <вызов функции>
    | <цикл for> 
    | <условный оператор if> 
    | <операция присвоения> 
    | <операция инициализации>

<пробельная последовательность> ::= (<пробел> | <комментарий>) (<пробельная последовательность> | <пусто>)
<комментарий> ::= "#" <последовательность символов> "\n"

<объявление функции> ::= (<тип данных> | "void") <пробельная последовательность> <переменная> "(" (<список аргументов> | <пусто>) ")" "{" 
    (<программа> | <программа> <выход из функции> (<пробельная последовательность> <набор базовых элементов> | <пусто>) ";")
"}"

<список аргументов> ::= <аргумент> | <аргумент> "," <список аргументов>
<аргумент> ::= <переменная> ":" <тип данных>

<вызов функции> ::= <переменная> "(" <набор базовых элементов> ")" ";"
<выход из функции> ::= "return"

<цикл for> ::= "for" "[" 
    (<операция инициализации> | <операция присвоения> | <пусто>) ";" 
    (<булево выражение> | <пусто>) ";"
    (<операция присвоения> | <пусто>) 
"]" "{" <тело цикла> "}"

<тело цикла> ::= <операции в цикле> | <тело цикла> <операции в цикле>
<операции в цикле> ::= <программа> | <манипуляции циклом>
<манипуляции циклом> ::= "break" ";" | "continue" ";"

<условный оператор if> ::= "if" "[" <булево выражение> "]" "{" <программа> "}"

<операция инициализации> ::= <переменная> ":" <тип данных> "=" (<выражение> | <операция ввода>) ";"
<операция присвоения> ::= <переменная> "=" (<выражение> | <операция ввода>) ";"

<операция ввода> ::= "input" "(" (<число> | <пусто>) ")"
<операция вывода> ::= "print" "(" (<набор базовых элементов> | <пусто>) ")"

<тип данных> ::= "int" | "str"

<булево выражение> ::= <булево OR>
<булево OR> ::= <булево AND> | <булево OR> "or" <булево AND>
<булево AND> ::= <булево NOT> | <булево AND> "and" <булево NOT>
<булево NOT> ::= <булева единица> | "not" <булево NOT>
<булева единица> ::= "(" <булево выражение> ")" | <выражение> <операция сравнения> <выражение> 

<выражение> ::= <слагаемое> | <слагаемое> ("+" | "-") <слагаемое> 
<слагаемое> ::= <множитель> | <множитель> ("*" | "/" | "%") <множитель>
<множитель> ::= <базовый элемент> | "(" <выражение> ")"

<операция сравнения> ::= "==" | "<" | "<=" | ">" | ">=" | "!="

<число> ::= <последовательность цифр> 
    | "-" <последовательность цифр>
    | <число> <операция побитового сдвига> <число>

<последовательность цифр> ::= <цифра> | <цифра> <последовательность цифр>

<операция побитового сдвига> ::= "<<" | ">>"

<строка> ::= '"' (<последовательность символов> | <пусто>) '"'
<последовательность символов> ::= <символ> | <символ> <последовательность символов>
<символ> ::= <цифра> | <буква> | <пробел> | "_"

<переменная> ::= (<буква> | "_") | (<буква> | "_") <название переменной>
<название переменной> ::= <символ переменной> | <символ переменной> <название переменной> 
<символ переменной> ::= <цифра> | <буква> | "_"

<набор базовых элементов> ::= <базовый элемент> | <базовый элемент> "," <набор базовых элементов>
<базовый элемент> ::= <переменная> | <число> | <строка> | <вызов функции>

<пусто> ::= ε
<пробел> ::= "\n" | "\t" | " "
<цифра> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
<буква> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" 
    | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" 
    | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" 
    | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" 
    | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" 
```

## Описание семантики

### Стратегия вычислений
Аргументы функции вычисляются до вызова функции, слева-направо. Вычисленное значение копируется в новую область памяти, выделенную специально для аргументов функции.

### Область видимости
Область видимости переменных ограничена фигурными скобками, в которых она была объявлена (если переменная объявлена вне скобок, то она находится в глобальной области видимости). За пределами этих фигурных скобок переменная не видна. Переменная может быть успешно изменена в новом уровне вложенности, без создания новой. Переменные с одинаковым именем не могут быть объявлены на одном и том же уровне видимости, но могут быть объявлены на разных (даже если один уровень видимости является вложением для другого).
```
number:int = 3
if [number < 5] {
    number = number + 1;
}
print(number);  # 4
```
```
number:int = 3
if [number < 5] {
    number:int = 4
    number = number + 1;
    print(number);  # 5
}
print(number);  # 3
```
Для функций работают те же правила области видимости, что и для переменных.
```
void do_something() {
    do_print();

    void do_print() {
        print(52);
    }
}

do_something();  # 52
do_print();  # Ошибка
```

### Типизация. Виды литералов
Типизация сильная и строгая. При этом есть следующие типы данных:
 - `str` - строковый тип данных, текст пишется в двойных кавычках.
 - `int` - численный тип данных, используется только для целых чисел.

Булевый тип данных отсутствует, вместо него следует использовать `int`.

# Организация памяти

## Машинное слово
В данной лабораторной работе используется фон Неймовская 32-битная архитектура (соотвественно, ширина машинного слова - 32 бита). Порядок байтов в машинном слове - little-endian.

## Регистры
Модель процессора включает себя следующий набор служебных регистров, недоступных для изменения программистом:
 - `PC` - 32-битный регистр, который хранит адрес следующей инструкции
 - `NZVC` - 4-битный регистр, хранящий флаги
 - Теневые регистры для обработки прерываний
<!-- TODO: дополнить раздел, когда будет сделана модель процессора -->

Помимо служебных, процессора включает в себя 32 регистра, доступных программисту: `R1`, `R2`, `R3`, `R4`, `R5`, `R6`, `R7`, `R8`, `R9`, `R10`, `R11`, `R12`, `R13`, `R14`, `R15`, `R16`, `A1`, `A2`, `A3`, `A4`, `A5`, `A6`, `A7`, `A8`, `T1`, `T2`, `T3`, `T4`, `T5`, `T6`, `Ra`, `Sp`.<br>

Назначение регистров:
 - `Sp` - адрес верхушки стека
 - `Ra` - адрес возврата из функции
 - `A1`-`A8` - аргументы и возвращаемое значение функции, если регистров не хватает, используется стек
 - `T1`-`T6` - регистры общего назначения, должны сохраняться вызывающей стороной (caller-saved регистры)
 - `R1`-`R15` - регистры общего назнчаения, должны сохраняться вызванной стороной (callee-saved регистры)

Примечание: отвественность за обработку регистров `Sp` и `Ra` полностью лежит на плечах программиста, никакая из команд не изменяет значения этих переменных по умолчанию.

## Варианты адресации
Аннотация: в кодируемых командах длина КОП = 8 бит, длина идентификатора регистра = 5 бит.

### Абсолютная адресация
Абсолютная адресация применяется в следующих ситуациях:
 - Загрузки в регистр значения из ячейки по абсолютному адресу.
 - Сохранение значения из регистра в ячейку по абсолютному адресу.

```
31                                          13          8                 0
+-------------------------------------------+-----------+-----------------+
|                   АДРЕС                   |  РЕГИСТР  |       КОП       |
+-------------------------------------------+-----------+-----------------+
```

Так как в данном варианте адрес занимает 19 бит, максимальное значение, которое можно загрузить таким образом: `0X7FFFF` (что соотвествует `2^19 - 1` в десятичной системе счисления).

### Прямая косвенная адресация
Косвенная адресация применяется в следующих ситуациях:
 - Загрузка в регистр значения из ячейки, адрес которой лежит в ячейке по указанному в команде адресу.
 - Сохранение значения из регистра в ячейку, адрес которой лежит в ячейке по указанному в команде адресу.

```
31                                          13          8                 0
+-------------------------------------------+-----------+-----------------+
|                   АДРЕС                   |  РЕГИСТР  |       КОП       |
+-------------------------------------------+-----------+-----------------+
```

Кодирование этой адресации схоже со случаем кодирования абсолютной адресации.

### Относительная косвенная адресация
Относительная косвенная применяется в следующих ситуациях:
 - Загрузка в регистр значения по адресу (с заданным смещением), который лежит в другом регистре.
 - Сохранение значения из регистра по адресу (с заданным смещением), который лежит в другом регистре.

```
31                               18          13          8                 0
+--------------------------------+-----------+-----------+-----------------+
|            СМЕЩЕНИЕ            |  РЕГИСТР  |  РЕГИСТР  |       КОП       |
+--------------------------------+-----------+-----------+-----------------+
```

Смещение занимает 14 бит, максимальное значение смещения, которое можно задать таким образом: `0X3FFF` (что соотвествует `2^14 - 1` в десятичной системе счисления).

### Безадресная адресация
Адресация, которая применяется используется в большинстве команд для данной архитектуры. Она работает только с регистрами, без обращения к памяти. Сюда входят: арифметические операции, побитовые операции и операции ветвления. Также стоит обратить внимание, что у операций ветвления есть несколько вариантов кодировки, т.к. разные варианты используют разное количество регистров.<br>

Арифметические и побитовые операции:
```
31                  23          18          13          8                 0
+-------------------+-----------+-----------+-----------+-----------------+
| 0 0 0 0 0 0 0 0 0 |  РЕГИСТР  |  РЕГИСТР  |  РЕГИСТР  |       КОП       |
+-------------------+-----------+-----------+-----------+-----------------+
```

Операции ветвления:
```
31                                          13          8                 0
+--------------------------------------------+-----------+-----------------+
|                   СМЕЩЕНИЕ                 |  РЕГИСТР  |       КОП       |
+--------------------------------------------+-----------+-----------------+
```
```
31                               18          13          8                 0
+--------------------------------+-----------+-----------+-----------------+
|            СМЕЩЕНИЕ            |  РЕГИСТР  |  РЕГИСТР  |       КОП       |
+--------------------------------+-----------+-----------+-----------------+
```
```
31                   23          18          13          8                 0
+--------------------+-----------+-----------+-----------+-----------------+
|      СМЕЩЕНИЕ      |  РЕГИСТР  |  РЕГИСТР  |  РЕГИСТР  |       КОП       |
+--------------------+-----------+-----------+-----------+-----------------+
```

### Прямая загрузка
Прямая загрузка нужна для загрузки литерала в регистр.
```
31                                         13          8                 0
+------------------------------------------+-----------+-----------------+
|                 ЗНАЧЕНИЕ                 |  РЕГИСТР  |       КОП       |
+------------------------------------------+-----------+-----------------+
```

## Расположение данных в памяти
Как уже было сказано ранее, процессор использует концепцию фон Неймана, поэтому все инструкции, данные, процедуры и т.д. находятся на одной ленте памяти. При этом, расположены в памяти они следующим образом:
```     
+--------------------------------------------------+
|                Вектора прерываний                |
+--------------------------------------------------+
| 00  : вектор прерывания 1                        |
| 01  : вектор прерывания 2                        |
|    ...                                           |
| 0F  : вектор прерывания 16                       |
+--------------------------------------------------+
|                Порты ввода-вывода                |
+--------------------------------------------------+
| 10  : порт ввода                                 |
| 11  : порт вывода                                |
+--------------------------------------------------+
|               Константы (c - метка)              |
+--------------------------------------------------+
| c+0 : константные данные 1                       |
| c+1 : константные данные 2                       |
|    ...                                           |
| c+N : константные данные N                       |
+--------------------------------------------------+
|              Переменные (d - метка)              |
+--------------------------------------------------+
| d+0 : переменная 1                               |
| d+1 : переменная 2                               |
|    ...                                           |
| d+N : переменная N                               |
+--------------------------------------------------+
|          Основная программа (p - метка)          |
+--------------------------------------------------+
| p+0 : инструкция 1                               |
| p+1 : инструкция 2                               |
|    ...                                           |
| p+N : инструкция N                               |
+--------------------------------------------------+
|  Процедуры и обработчики прерываний (f - метка)  |
+--------------------------------------------------+
| f+0 : процедура/обработчик 1                     |
|    ...                                           |
| f+N : процедура/обработчик N                     |
+--------------------------------------------------+
|                       Стек                       |
+--------------------------------------------------+
| ??? : конец стека                                |
|    ...                                           |
| MAX : начало стека                               |
+--------------------------------------------------+
```

### Вектора прерываний
Всего доступно 16 векторов прерываний (из них используется не все, большая часть - резерв), которые расположены в самом начале памяти. По этим адресам находятся адреса обработчиков прерываний. Если прерывание не обрабатывается, то нужно все-равно оставить обработчик-заглушку (обработчик, который будет ничего не делать и возвращать программу в обычный поток выполнения).<br><br>
Обработка прерывания является аппаратно-программной: системные регистры сохраняются системой в теневые регистры, все остальные регистры должны быть сохранены программистом.

### Порты ввода-вывода
Порты ввода и вывода мапятся на адреса памяти. Конфигурация процессора по умолчанию делает это на адреса, которые находятся сразу же за портами ввода и вывода.

### Константы
Константные значения идут после портов ввода-вывода. Все константы располагаются вплотную друг к другу (а если точнее, вплотную располагаются машинные слова с константами). Является ли переменная константой - определяет компилятор или программист.

### Переменные
Переменные идут после констант. Если переменная является числом (или любым другим типом данных, для хранения которого нужно фиксированное количество машинных слов), то она располагается вплотную к следующей за ней переменной. Иначе, нужное место для переменной вычисляется компилятором.<br><br>
Стоит отметить, что численные переменные (или любые другие, если они помещаются в одно машинное слово) отображаются в регистры общего назначения. Только если регистров не хватает, переменная отображается в память.

### Основная программа
Основная программа находится после переменных. Ее точное положение определяется компилятором.

### Процедуры и обработчики прерываний
Процедуры и обработчики перерываний (которые по своей сути тоже являются процедурами), находятся сразу же за основной программой. Важно не забывать, что отвественность за поток выполнения программы лежит на программисте.

### Стек
В данной модели памяти стек не является аппаратной частью и реализуется полностью программно. Компилятор располагает его в самом конце памяти (с оглядкой на доступность через косвенную адресацию) и растит его вниз.

# Система команд

<!--## Описание команд
TODO: добавить такты
Условные обозначения:
 - `<rN>` - любой из доступных регистров для программиста, где `N` - идентификатор регистра в контексте описания синтаксиса
 - `<addr>` - адрес в памяти программы, записывается в 16-ричном формате
 - `mem[...]` - значение, которое находится в `...` (вместо `...` может быть `<rN>`, `<addr>` и `mem[...]`)
 - `<value>` - значение для прямой загрузки в регистр

### Работа с регистрами
|     синтаксис     |  мнемоника  |      описание      |
|-------------------|-------------|--------------------|
| ldi <r1> <value>  | LOAD_IMM    | <value> -> <r1>    |
|-------------------|-------------|--------------------|
| mov <r1> <r2>     | MOVE        | mem[<r2>] -> <r1>  |

### Работа с памятью
|     синтаксис     |  мнемоника  |      описание      |
|-------------------|-------------|--------------------|
|                   |             |                    |

### Работа с памятью
|     синтаксис     |  мнемоника  |      описание      |
|-------------------|-------------|--------------------|
|                   |             |                    |

### Арифметические операции
Будет позже...

### Битовые операции
Будет позже...

### Управление потоком исполнения
Будет позже...

## Бинарное представление команд-->
Будет позже...

# Транслятор
Будет позже...

# Модель процессора
Будет позже...
